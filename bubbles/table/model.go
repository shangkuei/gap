package table

import (
	"errors"
	"fmt"
	"log/slog"
	"slices"
	"strings"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/charmbracelet/lipgloss/table"
	"github.com/google/uuid"
	"github.com/shangkuei/gap/bubbles"
)

// Model defines a state for the table widget.
type Model struct {
	KeyMap KeyMap
	Styles Styles

	rows         []Row
	columns      []Column
	cursorRow    int
	cursorColumn int
	minWidth     int

	focus bool

	viewport viewport.Model
	start    int
	end      int

	id uuid.UUID
}

// Row represents one line in the table.
type Row []any

// Column defines the table structure.
type Column struct {
	Title  string
	Width  int
	Cursor bool

	right int
	left  int
}

// KeyMap defines keybindings. It satisfies to the help.KeyMap interface, which
// is used to render the menu.
type KeyMap struct {
	LineLeft   key.Binding
	LineRight  key.Binding
	LineUp     key.Binding
	LineDown   key.Binding
	PageUp     key.Binding
	PageDown   key.Binding
	GotoTop    key.Binding
	GotoBottom key.Binding
	CellFocus  key.Binding
}

// DefaultKeyMap returns a default set of keybindings.
func DefaultKeyMap() KeyMap {
	return KeyMap{
		LineLeft: key.NewBinding(
			key.WithKeys("left"),
			key.WithHelp("←", ""),
		),
		LineRight: key.NewBinding(
			key.WithKeys("right"),
			key.WithHelp("→", ""),
		),
		LineUp: key.NewBinding(
			key.WithKeys("up"),
			key.WithHelp("↑", ""),
		),
		LineDown: key.NewBinding(
			key.WithKeys("down"),
			key.WithHelp("↓", ""),
		),
		PageUp: key.NewBinding(
			key.WithKeys("pgup"),
			key.WithHelp("PGUP", ""),
		),
		PageDown: key.NewBinding(
			key.WithKeys("pgdown"),
			key.WithHelp("PGDOWN", ""),
		),
		GotoTop: key.NewBinding(
			key.WithKeys("home"),
			key.WithHelp("HOME", ""),
		),
		GotoBottom: key.NewBinding(
			key.WithKeys("end"),
			key.WithHelp("END", ""),
		),
	}
}

// Styles contains style definitions for this list component. By default, these
// values are generated by DefaultStyles.
type Styles struct {
	Header       func() lipgloss.Style
	Cell         func() lipgloss.Style
	CursorHeader func() lipgloss.Style
	CursorRow    func() lipgloss.Style
	CursorColumn func(int) lipgloss.Style
	Border       lipgloss.Border
	BorderHeader bool
	BorderRow    bool
	BorderColumn bool
	BorderTop    bool
	BorderBottom bool
	BorderLeft   bool
	BorderRight  bool
}

// StyleFunc sets the style for a cell based on it's position (row, column).
func (s Styles) Table(row, column int) *table.Table {
	t := table.New().
		Border(s.Border).
		BorderHeader(s.BorderHeader).
		BorderRow(s.BorderRow).
		BorderColumn(s.BorderColumn).
		BorderTop(s.BorderTop).
		BorderBottom(s.BorderBottom).
		BorderLeft(s.BorderLeft).
		BorderRight(s.BorderRight).
		StyleFunc(func(r, c int) lipgloss.Style {
			switch {
			case r == 0:
				if c == column && s.CursorHeader != nil {
					return s.CursorHeader()
				}
				if s.Header != nil {
					return s.Header()
				}
				return s.Cell()
			case r == row:
				if c == column && s.CursorColumn != nil {
					return s.CursorColumn(c)
				}
				if s.CursorRow != nil {
					return s.CursorRow()
				}
				return s.Cell()
			default:
				return s.Cell()
			}
		})
	return t
}

func (s Styles) BorderHeight() int {
	return btoi(s.BorderTop) + btoi(s.BorderHeader) + btoi(s.BorderBottom)
}

// DefaultStyles returns a set of default style definitions for this table.
func DefaultStyles() Styles {
	return Styles{
		Cell:         func() lipgloss.Style { return lipgloss.NewStyle() },
		CursorRow:    func() lipgloss.Style { return lipgloss.NewStyle().Bold(true) },
		CursorColumn: func(_ int) lipgloss.Style { return lipgloss.NewStyle().Bold(true).Background(lipgloss.Color("212")) },
		Border: lipgloss.Border{
			Top:          "-",
			Bottom:       "-",
			Left:         "|",
			Right:        "|",
			TopLeft:      "-",
			TopRight:     "-",
			BottomLeft:   "-",
			BottomRight:  "-",
			MiddleLeft:   "-",
			MiddleRight:  "-",
			Middle:       "-",
			MiddleTop:    "-",
			MiddleBottom: "-",
		},
	}
}

func New(columns []Column, opts ...func(Model) Model) Model {
	model := Model{
		KeyMap:   DefaultKeyMap(),
		Styles:   DefaultStyles(),
		columns:  columns,
		viewport: viewport.New(0, 0),
		id:       uuid.New(),
	}
	model.cursorRow = -1
	model.cursorColumn = slices.IndexFunc(model.columns, func(col Column) bool {
		return col.Cursor
	})
	left, right, length := -1, len(model.columns), len(model.columns)
	for i := 0; i < len(model.columns); i++ {
		if model.columns[i].Cursor {
			model.columns[i].left, left = left, i
		} else {
			model.columns[i].left = -1
		}
		if model.columns[length-1-i].Cursor {
			model.columns[length-1-i].right, right = right, length-1-i
		} else {
			model.columns[length-1-i].right = -1
		}
		model.minWidth += model.columns[i].Width
	}

	for _, opt := range opts {
		model = opt(model)
	}
	return model
}

func (m Model) Init() tea.Cmd {
	return nil
}

// Update is the Bubble Tea update loop.
func (m Model) Update(msg tea.Msg) (_ tea.Model, cmd tea.Cmd) {
	var cmds []tea.Cmd

	focused := m.Focused()
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch {
		case focused && key.Matches(msg, m.KeyMap.LineLeft):
			m.MoveLeft()
		case focused && key.Matches(msg, m.KeyMap.LineRight):
			m.MoveRight()
		case focused && key.Matches(msg, m.KeyMap.LineUp):
			m.MoveUp(1)
		case focused && key.Matches(msg, m.KeyMap.LineDown):
			m.MoveDown(1)
		case key.Matches(msg, m.KeyMap.PageUp):
			m.PageUp()
		case key.Matches(msg, m.KeyMap.PageDown):
			slog.Info("page down")
			m.PageDown()
		case key.Matches(msg, m.KeyMap.GotoTop):
			m.GotoTop()
		case key.Matches(msg, m.KeyMap.GotoBottom):
			m.GotoBottom()
		}
	}
	return m, bubbles.Batch(cmds...)
}

// View renders the component.
func (m Model) View() string {
	return m.viewport.View()
}

func (m Model) ID() uuid.UUID {
	return m.id
}

// Focused returns the focus state of the table.
func (m Model) Focused() bool {
	return m.focus
}

// Focus focuses the table, allowing the user to move around the rows and
// interact.
func (m *Model) Focus() tea.Cmd {
	m.focus = true
	m.UpdateViewport()
	return nil
}

// Blur blurs the table, preventing selection or movement.
func (m *Model) Blur() tea.Cmd {
	m.focus = false
	m.UpdateViewport()
	return nil
}

func (m Model) Cell() (any, error) {
	if m.cursorRow == -1 || m.cursorColumn == -1 {
		return nil, errors.New("nonexistence cell")
	}
	if len(m.rows) <= m.cursorRow {
		return nil, errors.New("nonexistence cell")
	}
	if len(m.rows[m.cursorRow]) <= m.cursorColumn {
		return nil, errors.New("nonexistence cell")
	}
	return m.rows[m.cursorRow][m.cursorColumn], nil
}

func (m *Model) SetCell(cell any) {
	if m.cursorRow == -1 || m.cursorColumn == -1 {
		return
	}
	if len(m.rows) <= m.cursorRow {
		return
	}
	if len(m.rows[m.cursorRow]) <= m.cursorColumn {
		return
	}
	m.rows[m.cursorRow][m.cursorColumn] = cell
	m.UpdateViewport()
}

// UpdateViewport updates the list content based on the previously defined
// columns and rows.
func (m *Model) UpdateViewport() {
	var headers []string
	for _, column := range m.columns {
		headers = append(headers, column.Title+strings.Repeat(" ", max(column.Width-lipgloss.Width(column.Title), 0)))
	}

	var rows [][]string
	cursorRow, cursorColumn := -1, m.cursorColumn
	if len(m.rows) != 0 {
		// Render only rows from: m.cursor-m.viewport.Height to: m.cursor+m.viewport.Height
		// Constant runtime, independent of number of rows in a table.
		// Limits the number of renderedRows to a maximum of 2*m.viewport.Height
		// availableRowHeight := max(m.viewport.Height-1, 0)
		// start := clamp(m.cursorRow-availableRowHeight+1, 0, m.cursorRow)
		// end := clamp(start+availableRowHeight, m.cursorRow, len(m.rows))
		for _, r := range m.rows[m.start:m.end] {
			var row []string
			for _, cell := range r {
				if cell, ok := cell.(tea.Model); ok {
					row = append(row, cell.View())
					continue
				}
				row = append(row, fmt.Sprint(cell))
			}
			rows = append(rows, row)
		}

		if m.Focused() {
			cursorRow, cursorColumn = 1+m.cursorRow-m.start, m.cursorColumn
		}
	}

	content := m.Styles.
		Table(cursorRow, cursorColumn).
		Headers(headers...).
		Rows(rows...).
		Width(m.viewport.Width).
		Render()
	m.viewport.SetContent(content)
}

func (m *Model) SetRows(rows []Row) {
	m.rows = rows
	m.cursorRow = 0
	availableRowHeight := max(m.viewport.Height-1-m.Styles.BorderHeight(), 0)
	m.end = clamp(m.start+availableRowHeight, m.cursorRow, len(m.rows))
	m.UpdateViewport()
}

func (m *Model) SetWindow(height, width int) {
	m.viewport.Height, m.viewport.Width = height, max(m.minWidth, width)
	m.end = m.start + min(len(m.rows), m.viewport.Height-1-m.Styles.BorderHeight())
	m.UpdateViewport()
}

// Width returns the viewport width of the table.
func (m Model) Width() int {
	return m.viewport.Width
}

// Height returns the viewport height of the table.
func (m Model) Height() int {
	return m.viewport.Height
}

// Cursor returns the index of the selected row.
func (m Model) Cursor() (int, int) {
	return m.cursorRow, m.cursorColumn
}

// Cursor returns the index of the selected row.
func (m *Model) SetCursor(row, col int) {
	if len(m.rows) < row {
		return
	}
	if len(m.columns) < col || !m.columns[col].Cursor {
		return
	}
	m.cursorRow, m.cursorColumn = row, col
	m.UpdateViewport()
}

// MoveUp moves the selection up by any number of rows.
// It can not go above the first row.
func (m *Model) MoveLeft() {
	if m.cursorColumn < 0 || m.cursorColumn >= len(m.columns) {
		return
	}
	if m.columns[m.cursorColumn].left >= 0 {
		m.cursorColumn = m.columns[m.cursorColumn].left
		m.UpdateViewport()
	}
}

// MoveUp moves the selection up by any number of rows.
// It can not go above the first row.
func (m *Model) MoveRight() {
	if m.cursorColumn < 0 || m.cursorColumn >= len(m.columns) {
		return
	}
	if m.columns[m.cursorColumn].right < len(m.columns) {
		m.cursorColumn = m.columns[m.cursorColumn].right
		m.UpdateViewport()
	}
}

// MoveUp moves the selection up by any number of rows.
// It can not go above the first row.
func (m *Model) MoveUp(n int) {
	m.cursorRow = clamp(m.cursorRow-n, 0, max(len(m.rows)-1, 0))
	availableRowHeight := max(m.viewport.Height-1-m.Styles.BorderHeight(), 0)
	if m.start > m.cursorRow {
		m.end = clamp(m.cursorRow+availableRowHeight, m.cursorRow, len(m.rows))
		m.start = clamp(m.end-availableRowHeight, 0, m.cursorRow)
	}
	m.UpdateViewport()
}

// MoveDown moves the selection down by any number of rows.
// It can not go below the last row.
func (m *Model) MoveDown(n int) {
	m.cursorRow = clamp(m.cursorRow+n, 0, max(len(m.rows)-1, 0))
	availableRowHeight := max(m.viewport.Height-1-m.Styles.BorderHeight(), 0)
	if m.end <= m.cursorRow {
		m.start = clamp(m.cursorRow-availableRowHeight+1, 0, m.cursorRow)
		m.end = clamp(m.start+availableRowHeight, m.cursorRow, len(m.rows))
	}
	m.UpdateViewport()
}

func (m *Model) PageUp() {
	availableRowHeight := max(m.viewport.Height-1-m.Styles.BorderHeight(), 0)
	m.cursorRow = clamp(m.cursorRow-availableRowHeight, 0, max(len(m.rows)-1, 0))
	m.start = clamp(m.cursorRow-availableRowHeight+1, 0, m.cursorRow)
	m.end = clamp(m.start+availableRowHeight, m.cursorRow, len(m.rows))
	m.UpdateViewport()
}

func (m *Model) PageDown() {
	availableRowHeight := max(m.viewport.Height-1-m.Styles.BorderHeight(), 0)
	m.cursorRow = clamp(m.cursorRow+availableRowHeight, m.cursorRow, max(len(m.rows)-1, 0))
	m.end = clamp(m.cursorRow+availableRowHeight, m.end, len(m.rows))
	m.start = clamp(m.end-availableRowHeight, 0, m.cursorRow)
	m.UpdateViewport()
}

// GotoTop moves the selection to the first row.
func (m *Model) GotoTop() {
	m.MoveUp(m.cursorRow)
}

// GotoBottom moves the selection to the last row.
func (m *Model) GotoBottom() {
	m.MoveDown(len(m.rows))
}

func (m Model) KeyBindings() []key.Binding {
	if !m.Focused() {
		return []key.Binding{
			m.KeyMap.PageUp,
			m.KeyMap.PageDown,
			m.KeyMap.GotoTop,
			m.KeyMap.GotoBottom,
		}
	}

	return []key.Binding{
		m.KeyMap.LineLeft,
		m.KeyMap.LineRight,
		m.KeyMap.LineUp,
		m.KeyMap.LineDown,
		m.KeyMap.PageUp,
		m.KeyMap.PageDown,
		m.KeyMap.GotoTop,
		m.KeyMap.GotoBottom,
	}
}

func clamp(v, low, high int) int {
	return min(max(v, low), high)
}

func btoi(b bool) int {
	if b {
		return 1
	}
	return 0
}
