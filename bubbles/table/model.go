package table

import (
	"errors"
	"fmt"
	"strings"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/charmbracelet/lipgloss/table"
	"github.com/google/uuid"
	"github.com/shangkuei/gap/bubbles"
)

// Model defines a state for the table widget.
type Model struct {
	KeyMap KeyMap
	Styles Styles

	rows         []Row
	columns      []Column
	cursorRow    int
	cursorColumn int
	minWidth     int

	focus bool

	viewport viewport.Model
	start    int
	end      int

	id uuid.UUID
}

// Row represents one line in the table.
type Row []any

// Column defines the table structure.
type Column struct {
	Title  string
	Width  int
	Cursor bool

	right int
	left  int
}

// KeyMap defines keybindings. It satisfies to the help.KeyMap interface, which
// is used to render the menu.
type KeyMap struct {
	LineLeft   key.Binding
	LineRight  key.Binding
	LineUp     key.Binding
	LineDown   key.Binding
	PageUp     key.Binding
	PageDown   key.Binding
	GotoTop    key.Binding
	GotoBottom key.Binding
	CellFocus  key.Binding
}

// DefaultKeyMap returns a default set of keybindings.
func DefaultKeyMap() KeyMap {
	return KeyMap{
		LineLeft: key.NewBinding(
			key.WithKeys("left"),
			key.WithHelp("←", "left"),
		),
		LineRight: key.NewBinding(
			key.WithKeys("right"),
			key.WithHelp("→", "right"),
		),
		LineUp: key.NewBinding(
			key.WithKeys("up"),
			key.WithHelp("↑", "up"),
		),
		LineDown: key.NewBinding(
			key.WithKeys("down"),
			key.WithHelp("↓", "down"),
		),
		PageUp: key.NewBinding(
			key.WithKeys("pgup"),
			key.WithHelp("pgup", "page up"),
		),
		PageDown: key.NewBinding(
			key.WithKeys("pgdown"),
			key.WithHelp("pgdn", "page down"),
		),
		GotoTop: key.NewBinding(
			key.WithKeys("home"),
			key.WithHelp("home", "go to start"),
		),
		GotoBottom: key.NewBinding(
			key.WithKeys("end"),
			key.WithHelp("end", "go to end"),
		),
	}
}

// Styles contains style definitions for this list component. By default, these
// values are generated by DefaultStyles.
type Styles struct {
	Header       lipgloss.Style
	Cell         lipgloss.Style
	CursorRow    func(column int) lipgloss.Style
	CursorColumn func(column int) lipgloss.Style
}

// StyleFunc sets the style for a cell based on it's position (row, column).
func (s *Styles) Table(row, column int) *table.Table {
	t := table.New().
		BorderHeader(false).
		BorderRow(false).
		BorderColumn(false).
		BorderTop(false).
		BorderBottom(false).
		BorderLeft(false).
		BorderRight(false).
		StyleFunc(func(r, c int) lipgloss.Style {
			switch {
			case r == 0:
				return s.Header
			case r == row && c == column:
				return s.CursorColumn(c)
			case r == row:
				return s.CursorRow(c)
			default:
				return s.Cell
			}
		})
	return t
}

// DefaultStyles returns a set of default style definitions for this table.
func DefaultStyles() Styles {
	return Styles{
		Header:       lipgloss.NewStyle().Bold(true),
		Cell:         lipgloss.NewStyle(),
		CursorRow:    func(_ int) lipgloss.Style { return lipgloss.NewStyle().Bold(true) },
		CursorColumn: func(_ int) lipgloss.Style { return lipgloss.NewStyle().Bold(true).Background(lipgloss.Color("212")) },
	}
}

func New(columns []Column, opts ...func(*Model)) *Model {
	m := &Model{
		KeyMap:  DefaultKeyMap(),
		Styles:  DefaultStyles(),
		columns: columns,
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

func (m *Model) Init() tea.Cmd {
	m.id = uuid.New()
	left, right, length := -1, len(m.columns), len(m.columns)
	m.cursorRow = 0
	for i := 0; i < len(m.columns); i++ {
		if m.columns[i].Cursor {
			m.columns[i].left, left = left, i
		} else {
			m.columns[i].left = -1
		}
		if m.columns[length-1-i].Cursor {
			m.columns[length-1-i].right, right = right, length-1-i
		} else {
			m.columns[length-1-i].right = -1
		}
		m.minWidth += m.columns[i].Width
	}
	for i, column := range m.columns {
		if column.Cursor {
			m.cursorColumn = i
			break
		}
	}
	return nil
}

// Update is the Bubble Tea update loop.
func (m *Model) Update(msg tea.Msg) (_ tea.Model, cmd tea.Cmd) {
	if !m.focus {
		return m, nil
	}

	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch {
		case key.Matches(msg, m.KeyMap.LineLeft):
			m.MoveLeft()
		case key.Matches(msg, m.KeyMap.LineRight):
			m.MoveRight()
		case key.Matches(msg, m.KeyMap.LineUp):
			m.MoveUp(1)
		case key.Matches(msg, m.KeyMap.LineDown):
			m.MoveDown(1)
		case key.Matches(msg, m.KeyMap.PageUp):
			m.PageUp()
		case key.Matches(msg, m.KeyMap.PageDown):
			m.PageDown()
		case key.Matches(msg, m.KeyMap.GotoTop):
			m.GotoTop()
		case key.Matches(msg, m.KeyMap.GotoBottom):
			m.GotoBottom()
		}
	}
	return m, bubbles.Batch(cmds...)
}

// View renders the component.
func (m *Model) View() string {
	return m.viewport.View()
}

func (m *Model) ID() uuid.UUID {
	return m.id
}

// Focused returns the focus state of the table.
func (m *Model) Focused() bool {
	return m.focus
}

// Focus focuses the table, allowing the user to move around the rows and
// interact.
func (m *Model) Focus() (bool, tea.Cmd) {
	m.focus = true
	m.UpdateViewport()
	return true, nil
}

// Blur blurs the table, preventing selection or movement.
func (m *Model) Blur() (bool, tea.Cmd) {
	m.focus = false
	m.UpdateViewport()
	return true, nil
}

func (m *Model) Cell() (any, error) {
	if len(m.rows) <= m.cursorRow {
		return nil, errors.New("nonexistence cell")
	}
	if len(m.rows[m.cursorRow]) <= m.cursorColumn {
		return nil, errors.New("nonexistence cell")
	}
	return m.rows[m.cursorRow][m.cursorColumn], nil
}

// UpdateViewport updates the list content based on the previously defined
// columns and rows.
func (m *Model) UpdateViewport() {
	var headers []string
	for _, column := range m.columns {
		headers = append(headers, column.Title+strings.Repeat(" ", max(column.Width-lipgloss.Width(column.Title), 0)))
	}

	var rows [][]string
	cursorRow, cursorColumn := -1, -1
	if len(m.rows) != 0 {
		// Render only rows from: m.cursor-m.viewport.Height to: m.cursor+m.viewport.Height
		// Constant runtime, independent of number of rows in a table.
		// Limits the number of renderedRows to a maximum of 2*m.viewport.Height
		// availableRowHeight := max(m.viewport.Height-1, 0)
		// start := clamp(m.cursorRow-availableRowHeight+1, 0, m.cursorRow)
		// end := clamp(start+availableRowHeight, m.cursorRow, len(m.rows))
		for _, r := range m.rows[m.start:m.end] {
			var row []string
			for _, cell := range r {
				row = append(row, fmt.Sprint(cell))
			}
			rows = append(rows, row)
		}

		if m.Focused() {
			cursorRow, cursorColumn = 1+m.cursorRow-m.start, m.cursorColumn
		}
	}

	table := m.Styles.
		Table(cursorRow, cursorColumn).
		Headers(headers...).
		Rows(rows...).
		Width(m.viewport.Width)
	m.viewport.SetContent(table.Render())
}

func (m *Model) SetRows(rows []Row) {
	m.rows = rows
	m.end = min(m.start+m.viewport.Height, m.start+len(m.rows))
	m.UpdateViewport()
}

func (m *Model) SetWindow(height, width int) {
	m.viewport.Height, m.viewport.Width = height, max(m.minWidth, width)
	m.end = min(m.start+m.viewport.Height, m.end)
	m.UpdateViewport()
}

// Width returns the viewport width of the table.
func (m *Model) Width() int {
	return m.viewport.Width
}

// Height returns the viewport height of the table.
func (m *Model) Height() int {
	return m.viewport.Height
}

// Cursor returns the index of the selected row.
func (m *Model) Cursor() (int, int) {
	return m.cursorRow, m.cursorColumn
}

// MoveUp moves the selection up by any number of rows.
// It can not go above the first row.
func (m *Model) MoveLeft() {
	if m.columns[m.cursorColumn].left > 0 {
		m.cursorColumn = m.columns[m.cursorColumn].left
		m.UpdateViewport()
	}
}

// MoveUp moves the selection up by any number of rows.
// It can not go above the first row.
func (m *Model) MoveRight() {
	if m.columns[m.cursorColumn].right < len(m.columns) {
		m.cursorColumn = m.columns[m.cursorColumn].right
		m.UpdateViewport()
	}
}

// MoveUp moves the selection up by any number of rows.
// It can not go above the first row.
func (m *Model) MoveUp(n int) {
	m.cursorRow = clamp(m.cursorRow-n, 0, max(len(m.rows)-1, 0))
	availableRowHeight := max(m.viewport.Height-1, 0)
	m.end = clamp(m.cursorRow, m.end, len(m.rows))
	m.start = clamp(m.end-availableRowHeight, 0, m.cursorRow)
	m.UpdateViewport()
}

// MoveDown moves the selection down by any number of rows.
// It can not go below the last row.
func (m *Model) MoveDown(n int) {
	m.cursorRow = clamp(m.cursorRow+n, 0, max(len(m.rows)-1, 0))
	availableRowHeight := max(m.viewport.Height-1, 0)
	m.start = clamp(m.cursorRow-availableRowHeight+1, 0, m.cursorRow)
	m.end = clamp(m.start+availableRowHeight, m.cursorRow, len(m.rows))
	m.UpdateViewport()
}

func (m *Model) PageUp() {
	m.MoveUp(m.viewport.Height)
}

func (m *Model) PageDown() {
	m.MoveDown(m.viewport.Height)
}

// GotoTop moves the selection to the first row.
func (m *Model) GotoTop() {
	m.MoveUp(m.cursorRow)
}

// GotoBottom moves the selection to the last row.
func (m *Model) GotoBottom() {
	m.MoveDown(len(m.rows))
}

func clamp(v, low, high int) int {
	return min(max(v, low), high)
}
